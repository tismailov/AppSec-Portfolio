# unchecked_errors.yaml

Правило для детектирования игнорируемых ошибок в Go. Когда error возвращается функцией, но игнорируется через `_`, это может привести к неожиданному поведению программы и security-проблемам.

## Метаданные

- **Rule ID:** `unchecked_errors`
- **Severity:** HIGH
- **CWE:** CWE-252 (Unchecked Return Value)
- **OWASP:** A04:2025 - Insecure Design
- **Language:** Go
- **Confidence:** MEDIUM

## Описание уязвимости

В Go многие функции возвращают пару значений `(result, error)`. Игнорирование error через `_` (blank identifier) может привести к работе с невалидными данными, утечкам ресурсов или пропуску критических ошибок.

**Последствия:**

- Работа с неинициализированными/невалидными данными
- Утечки файловых дескрипторов и сетевых соединений
- Пропуск ошибок аутентификации или авторизации
- Непредсказуемое поведение программы в production

## Как работает правило

Правило использует один широкий паттерн:

```yaml
pattern: $VAR, _ := $FUNC($...ARGS)
```

## Что ловит:

- `$VAR` — переменная с результатом функции
- `_` — blank identifier (игнорирование error)
- `$FUNC` — любая функция
- `$...ARGS` — любые аргументы функции

**Примеры срабатывания:**

```jsx
f, _ := os.Open("file.txt") 
db, _ := sql.Open("mysql", dsn)       
data, _ := json.Marshal(obj)          
rows, _ := db.Query(query)           
```

## Метапеременные

- `$VAR` — переменная для результата
- `$FUNC` — имя функции
- `$...ARGS` — аргументы (может быть несколько или ноль)

## Примеры

## Уязвимо

**Вариант 1: Игнорирование ошибки открытия файла**

```jsx
f, _ := os.Open("config.txt")
defer f.Close()
data, _ := io.ReadAll(f)  // Если файл не открылся, f == nil → паника
```

**Вариант 2: Игнорирование ошибки подключения к БД**

```jsx
db, _ := sql.Open("mysql", "user:password@/dbname")
rows, _ := db.Query("SELECT * FROM users")  // Если БД недоступна → nil pointer
```

**Вариант 3: Игнорирование ошибки парсинга**

```jsx
num, _ := strconv.Atoi(userInput)  // Если userInput = "abc" → num = 0 (некорректный результат)
processNumber(num)                 // Работаем с дефолтным значением вместо реальной ошибки
```

**Почему опасно:**

Программа продолжает работу с невалидными данными (nil pointer, zero value), что приводит к паникам, некорректной логике или security-проблемам.

## Безопасно

**Вариант 1: Проверка критичных ошибок**

```jsx
f, err := os.Open("config.txt")
if err != nil {
    log.Fatalf("Failed to open config: %v", err)
}
defer f.Close()

data, err := io.ReadAll(f)
if err != nil {
    return fmt.Errorf("failed to read config: %w", err)
}
```

**Вариант 2: Обработка некритичных ошибок**

```jsx
// Если ошибка не критична, логируем и продолжаем
f, err := os.Open("optional-config.txt")
if err != nil {
    log.Printf("Optional config not found: %v", err)
    // Используем дефолтную конфигурацию
    return defaultConfig
}
defer f.Close()
```

**Вариант 3: Явное игнорирование с комментарием**

```jsx
// Ошибка Close() в defer обычно игнорируется намеренно
defer func() {
    _ = file.Close() // Явное игнорирование с комментарием
}()
```

## Результаты тестирования

При сканировании **Damn Vulnerable Golang** правило нашло **6 находок**:

## Находка 1: main.go, строка 68

```jsx
f, _ := os.Open("file.txt")
```

**Статус:** True Positive

**Критичность:** HIGH — может привести к nil pointer panic

## Находка 2: main.go, строка 79

```jsx
db, _ := sql.Open("mysql", "user:password@/dbname")
```

**Статус:** True Positive

**Критичность:** HIGH — программа не узнает об ошибке подключения к БД

## Находки 3-6: Аналогично

Все 6 находок — реальные проблемы, где игнорирование ошибок критично.

## Ограничения правила

Правило **не детектирует:**

1. **Игнорирование только error (без результата)**
    
    ```jsx
    _ = file.Close()  // Паттерн $VAR, _ не подходит
    ```
    
2. **Присваивание в существующую переменную**
    
    ```jsx
    var err error
    data, err = readData()  // Используется =, а не :=
    _ = err                 // Ошибка игнорируется позже
    ```
    
3. **Игнорирование через пустой if**
    
    ```jsx
    if _, err := os.Open("file"); err == nil {
        // Ошибка проверяется, но не обрабатывается
    }
    ```
    

## False Positives анализ

**Estimated FP Rate:** ~30-40%

**Возможные причины FP:**

1. **Некритичные функции**
    
    ```jsx
    // FP — ошибка Printf редко критична
    n, _ := fmt.Printf("Hello, %s", name)
    
    // FP — ошибка Write в буфер обычно игнорируется
    buf := &bytes.Buffer{}
    _, _ = buf.Write(data)
    ```
    
2. **Defer с Close()**
    
    ```jsx
    defer func() {
        _, _ = file.Close()  // FP — стандартная практика
    }()
    ```
    

## Рекомендации по исправлению

## Главная рекомендация

**Проверка ошибок от критичных операций: работа с файлами, сетью, БД, парсинг пользовательского ввода.**

**Базовый паттерн:**

```jsx
// Небезопасно:
f, _ := os.Open("file.txt")

// Безопасно:
f, err := os.Open("file.txt")
if err != nil {
    return fmt.Errorf("failed to open file: %w", err)
}
defer f.Close()
```

## Когда можно игнорировать

**1. Некритичные операции (с комментарием)**

```jsx
// Логирование — если не удалось, продолжаем работу
_, _ = fmt.Fprintf(logFile, "Log message")  // Явное игнорирование
```

**2. Defer Close()**

```jsx
defer func() {
    // Ошибка Close() в defer обычно не обрабатывается
    _ = file.Close()
}()
```

**3. Функции с гарантией успеха**

```jsx
// strings.Builder.Write() всегда возвращает nil error
var sb strings.Builder
_, _ = sb.WriteString("text")
```

## Best Practices

- **Логируйте критичные ошибки:** даже если продолжаете работу
- Проверяйте наличие ошибки: функции if err != nil